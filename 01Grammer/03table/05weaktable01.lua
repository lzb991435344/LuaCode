


a = {}
b = {__mode = "k"}
setmetatable(a, b) --‘a’的key是弱引用
key = {}   --第一个key
a[key] = 1
key = {}  --第二个key
a[key] = 2

--将 1回收
collectgarbage()  --强制进行一次垃圾回收
for k,v in pairs(a) do
	print(v)  --2
end


--[[
 1.垃圾回收器需要回收的两种情况
 (1)栈由数组和表示顶部的索引来实现，数组的有效部分总是向顶部扩展的
  当弹出一个元素只是递减顶部索引，这个仍留在数组中的对象不是垃圾
 (2)存储在全局变量中的对象,需要手动置为nill

2.简单清除引用无法实现垃圾回收，如对象在数组中就无法被回收

3.弱引用告诉lua一个引用不应该阻止一个对象的回收，会被垃圾收集器
忽视的对象的引用，无论key，value或者key,value都是弱引用，都最终
会被回收

4.元表中的__mode字段决定，字符串中包含k或v则是弱引用

5.注意：number和bool是不可回收的，如插入table的数字key,收集器不回收。
 但是如果value被回收了，则会被回收。

6.从程序员角度字符串是值，不是对象，不会从弱table中删除
]]--